{"version":3,"sources":["../../../AppData/Roaming/npm/node_modules/pixify/node_modules/browser-pack/_prelude.js","src/core/core.js","src/helpers/array.js","src/world/chunk.js","src/world/world.js","src/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixometric","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_world","Pixometric","stage","world","textures","textureLookup","_classCallCheck","generate","size","array","fill","generateFilled","object","generateFilledClasses","generate2D","width","height","x","generate2DFilled","y","generate2DFilledClasses","_array","ArrayHelpers","Chunk","voxels","sprites","_chunk","World","aoL","_chunk2","default","rotation","chunkX","chunkY","voxelZ","voxelY","Math","floor","voxelX","tmpX","tmpY","voxelIndex","voxelValue","spriteX","spriteY","sprite","PIXI","Sprite","addChild","destroy","generateSprites","_core","_core2","_world2"],"mappings":"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","file":"pixometric.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import World from \"../world/world\";\r\n\r\nexport default class Pixometric {\r\n    constructor(stage, world, textures, textureLookup) {\r\n        this.world = world;\r\n\r\n        // Make this global for easy access \r\n        Pixometric.stage = stage;\r\n        Pixometric.textures = textures;\r\n        Pixometric.textureLookup = textureLookup;\r\n    }\r\n}","// Optimalized filling methods\r\n// 1D\r\n\r\nexport function generate(size) {\r\n    var array;\r\n    (array = []).length = size;\r\n    return array.fill(0);\r\n}\r\n\r\nexport function generateFilled(size, object) {\r\n    var array;\r\n    (array = []).length = size;\r\n    for (var i = 0; i < size; i++) {\r\n        array[i] = object;\r\n    }\r\n    return array\r\n}\r\n\r\nexport function generateFilledClasses(size, object) {\r\n    var array;\r\n    (array = []).length = size;\r\n    for (var i = 0; i < size; i++) {\r\n        array[i] = new object;\r\n    }\r\n    return array;\r\n}\r\n\r\n// 2D\r\nexport function generate2D(width, height) {\r\n    var array;\r\n    (array = []).length = width;\r\n    for (var x = 0; x < width; x++) {\r\n        (array[x] = []).length = height;\r\n        array[x].fill(0);\r\n    }\r\n    return array;\r\n}\r\n\r\nexport function generate2DFilled(width, height, object) {\r\n    var array;\r\n    (array = []).length = width;\r\n    for (var x = 0; x < width; x++) {\r\n        (array[x] = []).length = height;\r\n        for (var y = 0; y < height; y++) {\r\n            array[x][y] = object;\r\n        }\r\n    }\r\n    return array;\r\n}\r\n\r\nexport function generate2DFilledClasses(width, height, object) {\r\n    var array;\r\n    (array = []).length = width;\r\n    for (var x = 0; x < width; x++) {\r\n        (array[x] = []).length = height;\r\n        for (var y = 0; y < height; y++) {\r\n            array[x][y] = new object;\r\n        }\r\n    }\r\n    return array;\r\n}","import * as ArrayHelpers from \"../helpers/array\";\r\n\r\n/**\r\n * \r\n * @todo Add possibility to change Chunk dimenstions\r\n * @export\r\n * @class Chunk\r\n */\r\nexport default class Chunk {\r\n    /**\r\n     * Creates an instance of Chunk.\r\n     * @param {Number} x \r\n     * @param {Number} y \r\n     * @memberof Chunk\r\n     */\r\n    constructor(x, y) {\r\n        // 16x16x16\r\n        this.voxels = ArrayHelpers.generateFilled(4096, 1);\r\n        this.sprites = [];\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}","import Chunk from \"./chunk\";\r\nimport * as ArrayHelpers from \"../helpers/array\";\r\n\r\nexport default class World {\r\n    /**\r\n     * Creates an instance of World.\r\n     * @todo Add option to disable rotation for better performance\r\n     * @todo Occulusion culling\r\n     * @todo Frustrum culling\r\n     * @todo Top-down view\r\n     * @todo Optimize rotation\r\n     * @memberof World\r\n     */\r\n    constructor() {\r\n        // Area of Interest, need to be recalculated after zooming\r\n        this.aoL = ArrayHelpers.generate2DFilledClasses(3, 3, Chunk);\r\n        \r\n        // 0 - 3\r\n        this.rotation = 0;\r\n    }\r\n\r\n    /**\r\n     * Generate PIXI sprites from Area of Interest\r\n     * @memberof World\r\n     */\r\n    generateSprites() {\r\n        // AoL Chunk x\r\n        for (var x = 0; x < this.aoL.length; x++) {\r\n            // AoL Chunk y\r\n            for (var y = 0; y < this.aoL[0].length; y++) {\r\n                // Calculate rotated real coordinates, without specific function for performance\r\n                // Thanks to tulevik.EU (http://www.indiedb.com/games/office-management-101/features/rotating-a-25d-isometric-map)\r\n                switch (this.rotation) {\r\n                    case 0:\r\n                        var chunkX = x;\r\n                        var chunkY = y;\r\n                        break;\r\n                    case 1:\r\n                        var chunkX = this.aoL.length - y - 1;\r\n                        var chunkY = x;\r\n                        break;\r\n                    case 2:\r\n                        var chunkX = this.aoL.length - x - 1;\r\n                        var chunkY = this.aoL[0].length - y - 1;\r\n                        break;\r\n                    case 3:\r\n                        var chunkX = y;\r\n                        var chunkY = this.aoL[0].length - x - 1;\r\n                }\r\n\r\n                // Voxels in current chunk\r\n                for (var i = 0; i < this.aoL[chunkX][chunkY].voxels.length; i++) {\r\n                    // Calculate position from 1d index\r\n                    var voxelZ = i % 16;\r\n                    var voxelY = (Math.floor(i / 16)) % 16;\r\n                    var voxelX = Math.floor(i / (16 * 16));\r\n\r\n                    // Calculate rotated real voxel coordinates\r\n                    // TODO: Optimize this \r\n                    switch (this.rotation) {\r\n                        case 0:\r\n                            var tmpX = voxelX;\r\n                            var tmpY = voxelY;\r\n                            break;\r\n                        case 1:\r\n                            var tmpX = 16 - voxelY - 1;\r\n                            var tmpY = voxelX;\r\n                            break;\r\n                        case 2:\r\n                            var tmpX = 16 - voxelX - 1;\r\n                            var tmpY = 16 - voxelY - 1;\r\n                            break;\r\n                        case 3:\r\n                            var tmpX = voxelY;\r\n                            var tmpY = 16 - voxelX - 1;\r\n                    }\r\n\r\n                    var voxelIndex = voxelZ + tmpY*16 + tmpX*16*16;\r\n\r\n                    // Get voxel block value\r\n                    var voxelValue = this.aoL[chunkX][chunkY].voxels[voxelIndex];\r\n\r\n                    // Check if current voxel is not air\r\n                    if (voxelValue != 0) {\r\n                        // Calculate sprite position\r\n                        var spriteX = ((voxelX - voxelY) + (x - y) * 16) * (32 / 2);\r\n                        var spriteY = ((voxelX + voxelY) + (x + y) * 16) * (32 / 4) - voxelZ * (32 / 2);\r\n                        \r\n                        // Create sprite from current block value\r\n                        var sprite = new PIXI.Sprite(Pixometric.textures[Pixometric.textureLookup[voxelValue - 1]]);\r\n\r\n                        // Add reference to current chunk for culling and unloading\r\n                        this.aoL[x][y].sprites[i] = sprite;\r\n\r\n                        // Set calculated values as position\r\n                        sprite.x = spriteX;\r\n                        sprite.y = spriteY;\r\n\r\n                        // Add sprite to the stage\r\n                        Pixometric.stage.addChild(sprite);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate world\r\n     * \r\n     * @param {Number} rotation \r\n     * @memberof World\r\n     */\r\n    rotate(rotation) {\r\n        this.rotation = rotation;\r\n        for (var x = 0; x < this.aoL.length; x++) {\r\n            for (var y = 0; y < this.aoL[0].length; y++) {\r\n                for (var i = 0; i < this.aoL[0][0].sprites.length; i++) {\r\n                    if (this.aoL[x][y].sprites[i]) {\r\n                        this.aoL[x][y].sprites[i].destroy();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.generateSprites();\r\n    }\r\n\r\n    /**\r\n     * Cull none visible voxels (behind each other)\r\n     * \r\n     * @memberof World\r\n     */\r\n    occlusionCulling() {\r\n        // \r\n    }\r\n} ","import Pixometric from \"./core/core\";\r\nimport World from \"./world/world\";\r\n\r\nPixometric.World = World;\r\n\r\nglobal.Pixometric = Pixometric;"],"sourceRoot":"."}