{"version":3,"sources":["../../../AppData/Roaming/npm/node_modules/pixify/node_modules/browser-pack/_prelude.js","src/core/config.js","src/core/core.js","src/helpers/array.js","src/world/chunk.js","src/world/manipulation/generate-sprites.js","src/world/manipulation/occulusion-culling.js","src/world/manipulation/rotate.js","src/world/world.js","src/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixometric","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","config","CHUNK","SIZE","HEIGHT","SPRITE","_world","Pixometric","stage","world","textures","textureLookup","_classCallCheck","generate","size","array","fill","generateFilled","object","generateFilledClasses","generate2D","width","height","x","generate2DFilled","y","generate2DFilledClasses","_array","ArrayHelpers","Chunk","voxels","sprites","generateSprites","aoL","rotation","chunkX","chunkY","voxelZ","voxelY","Math","floor","voxelX","tmpX","tmpY","voxelIndex","voxelValue","spriteX","spriteY","sprite","PIXI","Sprite","addChild","occlusionCulling","cull","z","found","index","visible","rotate","destroy","_generateSprites2","default","_generateSprites","_chunk","_occulusionCulling","_rotate2","World","_chunk2","_occulusionCulling2","_generateSprites3","_rotate3","_core","_config","_core2","_config2","_world2"],"mappings":"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","file":"pixometric.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var config = {\r\n    CHUNK: {\r\n        SIZE: 16,\r\n        HEIGHT: 16\r\n    },\r\n    SPRITE: {\r\n        SIZE: 32\r\n    }\r\n}\r\n\r\nexport default config; ","import World from \"../world/world\";\r\n\r\nexport default class Pixometric {\r\n    constructor(stage, world, textures, textureLookup) {\r\n        this.world = world;\r\n\r\n        // Make this global for easy access \r\n        Pixometric.stage = stage;\r\n        Pixometric.textures = textures;\r\n        Pixometric.textureLookup = textureLookup;\r\n    }\r\n}","// Optimalized filling methods\r\n// 1D\r\n\r\nexport function generate(size) {\r\n    var array;\r\n    (array = []).length = size;\r\n    return array.fill(0);\r\n}\r\n\r\nexport function generateFilled(size, object) {\r\n    var array;\r\n    (array = []).length = size;\r\n    for (var i = 0; i < size; i++) {\r\n        array[i] = object;\r\n    }\r\n    return array\r\n}\r\n\r\nexport function generateFilledClasses(size, object) {\r\n    var array;\r\n    (array = []).length = size;\r\n    for (var i = 0; i < size; i++) {\r\n        array[i] = new object;\r\n    }\r\n    return array;\r\n}\r\n\r\n// 2D\r\nexport function generate2D(width, height) {\r\n    var array;\r\n    (array = []).length = width;\r\n    for (var x = 0; x < width; x++) {\r\n        (array[x] = []).length = height;\r\n        array[x].fill(0);\r\n    }\r\n    return array;\r\n}\r\n\r\nexport function generate2DFilled(width, height, object) {\r\n    var array;\r\n    (array = []).length = width;\r\n    for (var x = 0; x < width; x++) {\r\n        (array[x] = []).length = height;\r\n        for (var y = 0; y < height; y++) {\r\n            array[x][y] = object;\r\n        }\r\n    }\r\n    return array;\r\n}\r\n\r\nexport function generate2DFilledClasses(width, height, object) {\r\n    var array;\r\n    (array = []).length = width;\r\n    for (var x = 0; x < width; x++) {\r\n        (array[x] = []).length = height;\r\n        for (var y = 0; y < height; y++) {\r\n            array[x][y] = new object;\r\n        }\r\n    }\r\n    return array;\r\n}","import * as ArrayHelpers from \"../helpers/array\";\r\n\r\n/**\r\n * Segment of World\r\n * @export\r\n * @class Chunk\r\n */\r\nexport default class Chunk {\r\n    /**\r\n     * Creates an instance of Chunk.\r\n     * @param {Number} x \r\n     * @param {Number} y \r\n     * @memberof Chunk\r\n     */\r\n    constructor(x, y) {\r\n        this.voxels = ArrayHelpers.generateFilled(Pixometric.config.CHUNK.SIZE * Pixometric.config.CHUNK.SIZE * Pixometric.config.CHUNK.HEIGHT, 1);\r\n        this.sprites = [];\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}","/**\r\n * Generate PIXI sprites from Area of Interest\r\n * \r\n * @export\r\n * @param {Chunk[][]} aoL \r\n * @param {Number} rotation \r\n */\r\nexport default function generateSprites(aoL, rotation) {\r\n    // AoL Chunk x\r\n    for (var x = 0; x < aoL.length; x++) {\r\n        // AoL Chunk y\r\n        for (var y = 0; y < aoL[0].length; y++) {\r\n            // Calculate rotated real coordinates, without specific function for performance\r\n            // Thanks to tulevik.EU (http://www.indiedb.com/games/office-management-101/features/rotating-a-25d-isometric-map)\r\n            switch (rotation) {\r\n                case 0:\r\n                    var chunkX = x;\r\n                    var chunkY = y;\r\n                    break;\r\n                case 1:\r\n                    var chunkX = aoL.length - y - 1;\r\n                    var chunkY = x;\r\n                    break;\r\n                case 2:\r\n                    var chunkX = aoL.length - x - 1;\r\n                    var chunkY = aoL[0].length - y - 1;\r\n                    break;\r\n                case 3:\r\n                    var chunkX = y;\r\n                    var chunkY = aoL[0].length - x - 1;\r\n            }\r\n\r\n            // Voxels in current chunk\r\n            for (var i = 0; i < aoL[chunkX][chunkY].voxels.length; i++) {\r\n                // Calculate position from 1d index\r\n                var voxelZ = i % Pixometric.config.CHUNK.SIZE;\r\n                var voxelY = (Math.floor(i / Pixometric.config.CHUNK.SIZE)) % Pixometric.config.CHUNK.SIZE;\r\n                var voxelX = Math.floor(i / (Pixometric.config.CHUNK.SIZE * Pixometric.config.CHUNK.SIZE));\r\n\r\n                // Calculate rotated real voxel coordinates\r\n                // TODO: Optimize this \r\n                switch (rotation) {\r\n                    case 0:\r\n                        var tmpX = voxelX;\r\n                        var tmpY = voxelY;\r\n                        break;\r\n                    case 1:\r\n                        var tmpX = Pixometric.config.CHUNK.SIZE - voxelY - 1;\r\n                        var tmpY = voxelX;\r\n                        break;\r\n                    case 2:\r\n                        var tmpX = Pixometric.config.CHUNK.SIZE - voxelX - 1;\r\n                        var tmpY = Pixometric.config.CHUNK.SIZE - voxelY - 1;\r\n                        break;\r\n                    case 3:\r\n                        var tmpX = voxelY;\r\n                        var tmpY = Pixometric.config.CHUNK.SIZE - voxelX - 1;\r\n                }\r\n\r\n                var voxelIndex = voxelZ + tmpY * Pixometric.config.CHUNK.SIZE + tmpX * Pixometric.config.CHUNK.SIZE * Pixometric.config.CHUNK.SIZE;\r\n\r\n                // Get voxel block value\r\n                var voxelValue = aoL[chunkX][chunkY].voxels[voxelIndex];\r\n\r\n                // Check if current voxel is not air\r\n                if (voxelValue != 0) {\r\n                    // Calculate sprite position\r\n                    var spriteX = ((voxelX - voxelY) + (x - y) * Pixometric.config.CHUNK.SIZE) * (Pixometric.config.SPRITE.SIZE / 2);\r\n                    var spriteY = ((voxelX + voxelY) + (x + y) * Pixometric.config.CHUNK.SIZE) * (Pixometric.config.SPRITE.SIZE / 4) - voxelZ * (Pixometric.config.SPRITE.SIZE / 2);\r\n\r\n                    // Create sprite from current block value\r\n                    var sprite = new PIXI.Sprite(Pixometric.textures[Pixometric.textureLookup[voxelValue - 1]]);\r\n\r\n                    // Add reference to current chunk for culling and unloading\r\n                    aoL[x][y].sprites[i] = sprite;\r\n\r\n                    // Set calculated values as position\r\n                    sprite.x = spriteX;\r\n                    sprite.y = spriteY;\r\n\r\n                    // Add sprite to the stage\r\n                    Pixometric.stage.addChild(sprite);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","\r\n/**\r\n * Cull none visible voxels (behind each other)\r\n * \r\n * @export\r\n * @param {Chunk[][]} aoL \r\n */\r\nexport default function occlusionCulling(aoL) {\r\n    // Check \"top\"\r\n    for (var chunkX = 0; chunkX < aoL.length; chunkX++) {\r\n        for (var chunkY = 0; chunkY < aoL[0].length; chunkY++) {\r\n            for (var x = 0; x < Pixometric.config.CHUNK.SIZE; x++) {\r\n                for (var y = 0; y < Pixometric.config.CHUNK.SIZE; y++) {\r\n                    cull(aoL, chunkX, chunkY, x, y, Pixometric.config.CHUNK.HEIGHT - 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check \"left\"\r\n    for (var chunkX = 0; chunkX < aoL.length; chunkX++) {\r\n        for (var x = 0; x < Pixometric.config.CHUNK.SIZE; x++) {\r\n            for (var z = 0; z < Pixometric.config.CHUNK.HEIGHT - 1; z++) {\r\n                cull(aoL, chunkX, aoL[0].length - 1, x, Pixometric.config.CHUNK.SIZE, z);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check \"right\"\r\n    for (var chunkY = 0; chunkY < aoL[0].length; chunkY++) {\r\n        for (var y = 0; y < Pixometric.config.CHUNK.SIZE; y++) {\r\n            for (var z = 0; z < Pixometric.config.CHUNK.HEIGHT - 1; z++) {\r\n                cull(aoL, aoL.length - 1, chunkY, Pixometric.config.CHUNK.SIZE - 1, y, z);\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Occlusion culling helper\r\n * \r\n * @param {Chunk[][]} aoL\r\n * @param {Number} chunkX \r\n * @param {Number} chunkY \r\n * @param {Number} x \r\n * @param {Number} y \r\n * @param {Number} z \r\n */\r\nfunction cull(aoL, chunkX, chunkY, x, y, z) {\r\n    var found = false;\r\n\r\n    while (true) {\r\n        if (z < 0) {\r\n            break;\r\n        }\r\n\r\n        if (y < 0) {\r\n            if (chunkY - 1 < 0) {\r\n                break;\r\n            } else {\r\n                chunkY--;\r\n                y = Pixometric.config.CHUNK.SIZE - 1;\r\n            }\r\n        }\r\n\r\n        if (x < 0) {\r\n            if (chunkX - 1 < 0) {\r\n                break;\r\n            } else {\r\n                chunkX--;\r\n                x = Pixometric.config.CHUNK.SIZE - 1;\r\n            }\r\n        }\r\n\r\n        // Calculate 1D index\r\n        var index = z + y * Pixometric.config.CHUNK.SIZE + x * Pixometric.config.CHUNK.SIZE * Pixometric.config.CHUNK.SIZE;\r\n\r\n        if (aoL[chunkX][chunkY].voxels[index] != 0) {\r\n            if (found) {\r\n                if (aoL[chunkX][chunkY].sprites[index]) {\r\n                    aoL[chunkX][chunkY].sprites[index].visible = false;\r\n                }\r\n            } else {\r\n                found = true;\r\n            }\r\n        }\r\n\r\n        x--;\r\n        y--;\r\n        z--;\r\n    }\r\n}","import generateSprites from \"./generate-sprites\";\r\n\r\n/**\r\n * Rotate world\r\n * \r\n * @export\r\n * @param {Chunk[][]} aoL \r\n * @param {Number} rotation \r\n */\r\nexport default function rotate(aoL, rotation) {\r\n    for (var x = 0; x < aoL.length; x++) {\r\n        for (var y = 0; y < aoL[0].length; y++) {\r\n            for (var i = 0; i < aoL[0][0].sprites.length; i++) {\r\n                if (aoL[x][y].sprites[i]) {\r\n                    aoL[x][y].sprites[i].destroy();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    generateSprites(aoL, rotation);\r\n}","import Chunk from \"./chunk\";\r\nimport occlusionCulling from \"./manipulation/occulusion-culling\";\r\nimport generateSprites from \"./manipulation/generate-sprites\";\r\nimport rotate from \"./manipulation/rotate\";\r\nimport * as ArrayHelpers from \"../helpers/array\";\r\n\r\nexport default class World {\r\n    /**\r\n     * Creates an instance of World.\r\n     * @todo Add option to disable rotation for better performance\r\n     * @todo Frustrum culling\r\n     * @todo Top-down view\r\n     * @memberof World\r\n     */\r\n    constructor() {\r\n        // Area of Interest, need to be recalculated after zooming\r\n        this.aoL = ArrayHelpers.generate2DFilledClasses(3, 3, Chunk);\r\n\r\n        // 0 - 3\r\n        this.rotation = 3;\r\n    }\r\n\r\n\r\n    /**\r\n     * Occlusion cullling algorithm\r\n     * \r\n     * @memberof World\r\n     */\r\n    occlusionCulling() {\r\n        occlusionCulling(this.aoL);\r\n    }\r\n\r\n    /**\r\n     * Generate PIXI sprites from Area of Interest\r\n     * \r\n     * @memberof World\r\n     */\r\n    generateSprites() {\r\n        generateSprites(this.aoL, this.rotation);\r\n    }\r\n\r\n    /**\r\n     * Rotate world\r\n     * \r\n     * @param {Number} rotation \r\n     * @memberof World\r\n     */\r\n    rotate(rotation) {\r\n        this.rotation = rotation;\r\n        rotate(this.aoL, this.rotation);\r\n    }\r\n\r\n    // Testing function\r\n    unloadChunk(x, y) {\r\n        for (var i = 0; i < Pixometric.config.CHUNK.SIZE * Pixometric.config.CHUNK.SIZE * Pixometric.config.CHUNK.HEIGHT; i++) {\r\n            if (this.aoL[x][y].sprites[i]) {\r\n                this.aoL[x][y].sprites[i].destroy();\r\n            }\r\n        }\r\n    }\r\n}","import Pixometric from \"./core/core\";\r\nimport config from \"./core/config\";\r\nimport World from \"./world/world\";\r\n\r\n// Add global config to Pixometric variable\r\nPixometric.config = config;\r\nPixometric.World = World;\r\n\r\nglobal.Pixometric = Pixometric;"],"sourceRoot":"."}